<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 196: Range Objects</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>

  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI logo" /></a>196: Range Objects</h1>

<p>by John Cowan (text), Wolfgang Corcoran-Mathe (implementation)</p>

<h2>Status</h2>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+196+at+srfi+dotschemers+dot+org">srfi-196@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-196">archive</a>.</p>
<ul>
  <li>Received: 2020-05-17</li>
  <li>60-day deadline: 2020-07-16</li>
  <li>Draft #1 published: 2020-05-17</li>
  <li>Draft #2 published: 2020-07-16</li>
  <li>Draft #3 published: 2020-07-19</li>
  <li>John Cowan's <a href="https://github.com/johnwcowan/srfi-196">personal
    Git repo for this SRFI</a> for reference while the SRFI is in
    <em>draft</em> status (<a href="https://htmlpreview.github.io/?https://github.com/johnwcowan/srfi-196/blob/master/srfi-196.html">preview</a>)</li>
</ul>

<h2>Abstract</h2>

<p>Ranges are immutable collections that can be enumerated but are
represented algorithmically rather than by a per-element data
structure.  This SRFI defines a large subset of the sequence operations
defined on lists, vectors, and other collections.  If necessary,
a range can be converted to a list or vector of its elements or a generator
that will lazily produce each element in the range.</p>

<h2>Issues</h2>

None at present.

<h2>Rationale</h2>

<p>One of the most common things to do in programming is to execute
a block of code a fixed number of times, with access to the index
used for the iteration.  Indeed, it is so common that there is generally
a standard syntax for providing it, generally involving the keyword
<code>for</code> (or if not, as in Fortran and Lisp, the word
<code>do</code>).  It is also usual to be able to provide a lower bound,
generally defaulting to 0 or 1, as well as step size, allowing
iterations through a sequence of odd numbers, or multiples of 10,
or whatever.</p>

<p>Languages with higher order functions, however, provide a second
approach to such loops: construct a sequence of numbers and apply
a function to each element of the sequence.  SRFI 1's <code>iota</code>
and the standard <code>for-each</code> procedures make this easy:
<code>(for-each (lambda (i) ...) (iota 0 10))</code>
will execute the expressions represented as <code>...</code>
with <code>i</code> bound to the numbers 0 through 9, as
the generated list includes the lower bound and excludes the upper bound.</p>

<p>This approach is less feasible as the number of numbers grows.
To iterate a million times involves constructing a list of a million
numbers to be iterated over and immediately discarded as garbage.
This is not something you want to do in the inner loop of your code.
The range objects of this SRFI represent such sequences using only
a small fixed amount of storage.  Using
<code>(range-for-each (lambda (i) ...) (numeric-range 0 1000000))</code>
iterates a million times but with less space overhead than
<code>iota</code>'s list of ten elements.</p>

<p>In addition, there are other sequences besides integers from
which a range may be drawn.  In particular, inexact numbers can
also specify ranges: <code>(numeric-range 0.0 1.0 0.1)</code>
specifies the sequence 0.0, 0.1, ... 0.9,
at least when inexact numbers are represented
as IEEE 754 binary double floats (as is usually the case).
Roundoff error is still possible by multiplying, but it is
greatly reduced compared to accumulated error by repeated adding.
</p>
<p>Two more examples:
</p>
<ul>
<li>The basic Latin capital letters A-Z can be specified using
a range constructed by <code>(range #\A 26
(lambda (c n) (integer->char (+ (char->integer c) n))))</code>.
</li>
<li>
The geometric sequence 1, 1/2, 1/4, &hellip;, 1/512 can be expressed by
<code>(range 1/2 10 expt)</code>.
</li></ul>

<h2>Specification</h2>

<p>Ranges belong to a disjoint type.
The size of a range object is independent of the
number of elements it contains.
Statements about running time exclude time spent in
the indexer procedure.
</p>

<p>This SRFI recommends, but does not require, that Scheme implementations
which also provide <a href="https://srfi.schemers.org/srfi-42/srfi-42.html">SRFI 42</a>
modify it so that the typed generator <code>:range</code> also accepts
a single argument which is a range in the sense of this SRFI.
This feature should be used with caution, as SRFI 42 loops expect
that <code>:range</code> iterates only over exact rationals.
</p>

<h3 id="constructors">Constructors</h3>
<p><code>(range</code>&nbsp;<em>lower-bound length indexer</em><code>)</code></p>
<p>Returns a range whose lower bound is <i>lower-bound</i>
and whose length (number of elements) is <i>length</i>.
The <i>indexer</i> procedure returns the <i>n</i>th element
(where 0 &#x2264; <i>n</i> &lt; <i>length</i>)
of the range given <i>lower-bound</i> and <i>n</i>.
This procedure must run in O(1) time.</p>

<p>There is a constraint on indexers:
It is an error if an indexer <code>ind</code>
does not satisfy the following identity:</p>
<blockquote>
<code>(ind lower-bound k)</code> is equal to
<code>(ind (ind lower-bound k) 0)</code>
</blockquote>
<p>for all values of <code>k</code> between 0 (inclusive)
and the highest value which will ever be passed as the
second argument to <code>ind</code> (exclusive).
This constraint cannot be checked by the implementation, but if
violated will cause various other procedures to misbehave.
</p>

<p><code>(numeric-range</code>&nbsp;<em>start end</em> [<em>step</em>]<code>)</code></p>
<p>Returns a numeric range, a special case of a range specified by an
inclusive lower bound <em>start</em>, an exclusive upper bound <em>end</em>, and a
<em>step</em> value (default 1), all of which can be exact or inexact real
numbers, and its indexer is
<code>(lambda (bound n) (+ bound (* n step)))</code>.
This procedure must run in O(1) time.</p>

<p>Note that an effect of this definition is that the elements of
a range over inexact numbers are enumerated by multiplying the index
by the step value rather than by adding the step value to itself
repeatedly.  This reduces the likelihood of roundoff errors.</p>


<h3 id="predicates">Predicates</h3>

<p><code>(range?</code>&nbsp;<em>obj</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>obj</em> is a range and <code>#f</code>
otherwise.
This procedure must run in O(1) time.</p>

<h3 id="accessors">Accessors</h3>

<p><code>(range-length</code>&nbsp;<em>range</em><code>)</code></p>
<p>Returns the length (number of elements) of <em>range</em>.
This procedure must run in O(1) time.</p>

<p><code>(range-indexer</code>&nbsp;<em>range</em><code>)</code></p>
<p>Returns the indexer of <em>range</em>.
This procedure must run in O(1) time.</p>

<p><code>(range-ref</code>&nbsp;<em>range n</em><code>)</code></p>
<p>Returns the <em>n</em>th element of <em>range</em>. It is an error if
<em>n</em> is less than 0 or greater than or equal to the length of
<em>range</em>.
This procedure must run in O(<em>n</em>) time.</p>

<p><code>(range-start</code>&nbsp;<em>range</em><code>)</code></p>
<p>Equivalent to <code>(range-ref</code>&nbsp;<em>range</em>
<code>0)</code>.
This procedure must run in O(1) time.</p>

<p><code>(range-end</code>&nbsp;<em>range</em><code>)</code></p>
<p>Equivalent to <code>(range-ref</code>&nbsp;<em>range</em> <code>(-
(range-length</code>&nbsp;<em>range</em><code>) 1))</code>.
This procedure must run in O(1) time.</p>

<h3 id="iteration">Iteration</h3>

<p><code>(range-split-at</code>&nbsp;<em>range index</em><code>)</code></p>
<p>Returns two values which are ranges. The first value contains all elements
of <em>range</em> from the zeroth element to the <em>index</em>th element
exclusive. The second value contains all elements of <em>range</em> from the
<em>index</em>th element inclusive to the last element.
This procedure must run in O(1) time.</p>
<p><code>(subrange</code>&nbsp;<em>range start end</em><code>)</code></p>
<p>Returns a range which contains the elements of
<i>range</i> from index <i>start</i>, inclusive, through index
<i>end</i>, exclusive.
This procedure must run in O(1) time.</p>

<p><code>(range-take</code>&nbsp;<em>range count</em><code>)</code><br>
<code>(range-take-right</code>&nbsp;<em>range count</em><code>)</code></p>
<p>Returns a range which contains the first/last <em>count</em> elements of
<em>range</em>.
These procedures must run in O(1) time.</p>

<p><code>(range-drop</code>&nbsp;<em>range count</em><code>)</code><br>
<code>(range-drop-right</code>&nbsp;<em>range count</em><code>)</code></p>
<p>Returns a range which contains all except the first/last <em>count</em> elements
of <em>range</em>.
These procedures must run in O(1) time.</p>

<p><code>(range-count</code>&nbsp;<em>pred range</em><code>)</code></p>
<p>Returns the number of elements of <em>range</em> which satisfy
<em>pred</em>.
This procedure must run in O(<em>n</em>) time.</p>

<p><code>(range-any</code>&nbsp;<em>pred range</em><code>)</code></p>
<p>Returns true if any of the elements of <em>range</em> satisfy <em>pred</em>.
Specifically it returns the last value returned by <em>pred</em>. Otherwise,
<code>#f</code> is returned.
This procedure must run in O(<em>n</em>) time.</p>

<p><code>(range-every</code>&nbsp;<em>pred range</em><code>)</code></p>
<p>Returns true if all the elements of <em>range</em> satisfy <em>pred</em>,
specifically it returns the last value returned by <em>pred</em> or
<code>#t</code> if <em>pred</em> was never invoked. Otherwise, <code>#f</code>
is returned.
This procedure must run in O(<em>n</em>) time.</p>

<p><code>(range-map-&gt;list</code>&nbsp;<em>proc range</em><code>)</code></p>
<p>Returns a list of the results of applying <em>proc</em> to each
element of <em>range</em> in order. However, the order in which
<em>proc</em> is actually applied to the elements is unspecified.
This procedure must run in O(<em>n</em>) time.</p>

<p><code>(range-for-each</code>&nbsp;<em>proc range</em><code>)</code></p>
<p>Applies <em>proc</em> to each element of <em>range</em> in order. Returns an
unspecified result.
This procedure must run in O(<em>n</em>) time.</p>

<p><code>(range-filter-&gt;list</code>&nbsp;<em>pred range</em><code>)</code><br>
<code>(range-remove-&gt;list</code>&nbsp;<em>pred range</em><code>)</code></p>
<p>Returns a list containing the elements of <em>range</em> that satisfy / do
not satisfy <em>pred</em>.
This procedure must run in O(<em>n</em>) time.</p>

<p><code>(range-fold</code>&nbsp;<em>proc nil range</em><code>)</code><br>
<code>(range-fold-right</code>&nbsp;<em>proc nil range</em><code>)</code></p>
<p>Invokes <em>proc</em> on each member of <em>range</em> in order / reverse order, passing the
result of the previous invocation as a second argument. For the first
invocation, <em>nil</em> is used as the second argument. Returns the result of
the last invocation, or <em>nil</em> if there was no invocation.
These procedures must run in O(<em>n</em>) time.</p>
<p><code>(range-reverse</code>&nbsp;<em>range</em><code>)</code></p>
<p>Returns a range which contains the same elements as <em>range</em>, but in
reverse order.
This procedure must run in O(1) time.</p>

<h3 id="searching">Searching</h3>

<p><code>(range-index</code>&nbsp;<em>pred range</em><code>)</code><br>
<code>(range-index-right</code>&nbsp;<em>pred range</em><code>)</code></p>
<p>Returns the index of the first/last element of <em>range</em> that satisfies
<em>pred</em>, or <code>#f</code> if there is none.
These procedures must run in O(<em>n</em>) time.</p>

<p><code>(range-take-while</code>&nbsp;<em>pred range</em><code>)</code><br>
<code>(range-take-while-right</code>&nbsp;<em>pred range</em><code>)</code></p>
<p>Returns a range containing the leading/trailing elements of <em>range</em> that satisfy
<em>pred</em> up to the first/last one that does not.
These procedures must run in O(<em>n</em>) time.</p>

<p><code>(range-drop-while pred</code>&nbsp;<em>range</em><code>)</code><br>
<code>(range-drop-while-right</code>&nbsp;<em>pred range</em><code>)</code></p>
<p>Returns a range that omits leading/trailing elements of <em>range</em> that satisfy
<em>pred</em> until the first/last one that does not.
These procedures must run in O(<em>n</em>) time.</p>

<h3 id="conversion">Conversion</h3>

<p><code>(range-&gt;list</code>&nbsp;<em>range</em><code>)</code><br>
<code>(range-&gt;vector</code>&nbsp;<em>range</em><code>)</code></p>
<p>Returns a list/vector containing the elements of <em>range</em> in order.
These procedures must run in O(<em>n</em>) time.</p>

<p><code>(range-&gt;generator</code>&nbsp;<em>range</em><code>)</code></p>
<p>Returns a SRFI 158 generator that generates the elements of <em>range</em>
in order.
This procedure must run in O(1) time,
and each call of the generator must run in O(1) time.

<h2>Implementation</h2>

<p>The sample implementation is in the repository of this SRFI.
An R7RS library file and a separate file containing the actual
implementation are provided, along with a test file that
works with SRFI 78, but is self-contained if SRFI 78 does not exist.
The implementation needs SRFI 128, and can take
advantage of SRFI 145 (<code>assume</code>) if it is present.</p>


<h2>Acknowledgements</h2>

<p>Without <a href="https://docs.python.org/3.8/library/stdtypes.html#ranges">Python's <code>range</code> object</a>,
this SRFI would not exist.  Thanks also to the contributors on the SRFI 196 mailing list.
</p>

<h2>Copyright</h2>
Copyright &copy; John Cowan, Wolfgang Corcoran-Mathe (2020).

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.
<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
